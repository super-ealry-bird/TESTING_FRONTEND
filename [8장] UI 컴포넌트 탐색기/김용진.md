# [8장] UI 컴포넌트 탐색기

---

## 8.1 스토리북 기초
UI 컴포넌트 탐색기는 구현된 UI 컴포넌트를 쉽게 공유할 수 있도록 도와주는 협업 도구다.
최근에는 UI 컴포넌트 탐색기를 협업 도구가 아닌 테스트에 활용하는 사례가 많아졌다.

기존의 프런트엔드 테스트는 다음의 두 가지 테스트를 의미했다.

- `jsdom`을 사용한 단위 테스트 및 통합테스트
- 브라우저를 사용한 E2E 테스트

스토리북의 UI컴포넌트 테스트는 이 두 가지 테스트의 중간에 위치한 테스트다.
![image](https://github.com/user-attachments/assets/e99d101e-ac17-4b37-85c7-16d917615d49)

### 8.1.1 스토리북 설치
스토리북 설치
```bash
$ npx storybook init
```

```bash
  storybook@8.2.9
Ok to proceed? (y)
```

스토리북 실행 http://localhost:6006/ 에 실행된다.
```bash
$ npm run storybook
```

### 8.1.2 스토리 등록
스토리를 등록하려면 프로젝트에 스토리 파일을 추가해야 한다.<br>
예제 코드 `Button.jsx`라는 UI 컴포넌트를 스토리 등록을 위해 필요한 스토리 파일 Button.stories.jsx 다.
```tsx
import { Button } from "./Button";

export default {
  title: "Example/Button",
  component: Button,
};
```

UI 컴포넌트 Props의 조합으로 다른 스타일과 작동을 제공할 수 있다.
Button 문자열을 표시할 때는 label 이라는 Props를 지정한다. ( 스토리북에서는 Props에 해당하는 변수명이 args 이다.)
```tsx
export const Default = {
  args: {
    label: "Button"
  }
};
```

size가 다른 `export` 객체 이름으로 개별 스토리 등록 
```tsx
export const Large = {
  args: {
    size: "large"
    label: "Button"
  }
};

export const Small = {
  args: {
    size: "small"
    label: "Button"
  }
};
```

### 8.1.3 3단계 깊은 병합
모든 스토리에는 'Global', Component', 'Story' 세 단계의 설정이 깊은 병합 방식으로 적용된다.

- Global 단계: 모든 스토리에 적용할 설정 (.storybook/preview.js)
- Component 단계: 스토리 파일에 적용할 설정 (export default)
- Story 단계: 개별 스토리에 적용할 설정 (export const)


## 8.2 스토리북 필수 애드온
스토리북은 애드온으로 필요한 기능을 추가할 수 있다. 설치시 기본적으로 추가되는 `@storybook/addon-essentials`은 필수 애드온 이다.

### 8.2.1 Controls를 활용한 디버깅
UI 컴포넌트는 Props에 전달된 값에 따라 다른 스타일과 기능을 제공한다. 스토리북 탐색기에서는 `Props`를 변경해 컴포넌트가 어떻게 표시되는지 실시간으로 디버깅할 수 있다. 이를 **Controls**라고 한다.

`Props`(`children`, `theme`, `variant`, `disabled`)를 변경하면 UI 컴포넌트가 어떻게 변화하는지 바로 확인할 수 있다.
![image](https://github.com/user-attachments/assets/548ffa1d-2b82-49e4-ab98-ebb491fcb9e5)

`@stroybook/addon-controls`라는 애드온이 제공하는 기능이며, 스도리북을 설치할 때 적용되는 `@storybook/addon-essentials`에 포함되어 있다.

### 8.2.2 Actions를 활용한 이벤트 핸들러 검증
UI 컴포넌트는 내부 로직을 처리할 때 `Props`로 전달받은 이벤트 핸들러를 호출하기도 한다. 이벤트 핸들러가 어떻게 호출됐는지 로그를 출력하는 기능이 **Actions**이며, `@stroybook/addon-actions`패키지에서 제공한다. `@storybook/addon-essentials`에 포함되어 있다.

title를 입력하지 않고, 저장하려고 하면 `onInvalid` 호출됐고 로그를 확인할 수 있다.
![image](https://github.com/user-attachments/assets/c24a1c83-3582-4768-969d-a9f22ceb7de6)


Global 단계 설정으로 `on`으로 시작하는 모든 이벤트 핸들러는 자동적으로 Actions 패널에 로그를 출력하게 된다.
핸들러 이름이 다른 경우 정규표현식을 수정해야 한다.
```tsx
export const parameters = {
  actions: { argTypesRegex: "^on[A-Z].*" },
};
```

### 8.2.3 반응형 대응을 위한 뷰포트 설정
반응형으로 구현한 UI 컴포넌트는 화면 크기별로 스토리를 등록할 수 있다. `@stroybook/addon-viewport`패키지에서 지원한다.

![image](https://github.com/user-attachments/assets/5cdd27d2-222f-4051-b93e-a7f0d34199d1)

레이아웃으로 스토리를 등록하려면 `parameters.viewport`를 설정해야한다. SP(스마트폰) `SPStroy`라는 공통된 설정을 만들었다.
```tsx
export const SPStory = {
  parameters: {
    viewport: {
      viewports: INITIAL_VIEWPORTS,
      defaultViewport: "iphone6",
    },
    screenshot: {  // 시각적 회기 테스트를 위한 설정
      viewport: {
        width: 375,
        height: 667,
        deviceScaleFactor: 1,
      },
      fullPage: false,
    },
  },
};

// 스마트폰 로그인 화면 
export const SPLoggedIn: Story = {
  parameters: {
    ...SPStory.parameters,
  },
}

// PC 로그인 화면 
export const PCLoggedIn: Story = {
  parameters: {
    ...PCStory.parameters,
  },
}
```

## 8.3 Context API에 의존하는 스토리 등록
Context API에 의존하는 스토리에는 **데커레이터**를 활용하는 것이 편리하다. 초깃값을 주입할 수 있도록 Provider를 만들면 Context의 상태에 의존하는 UI를 간단하게 재현할 수 있다.

### 8.3.1 스토리북의 데커레이터
데커레이터는 각 스토리의 렌더링 함수에 적용할 **래퍼**다. UI 컴포넌트 바깥쪽에 여백을 만들고 싶다면 데커레이터를 `decorators` 배열에 추가한다.
```tsx
import { ChildComponent } from "./";

export default {
  title: "ChildComponent",
  component: ChildComponent,
  decorators: [
    (Story) => (
      <div style={{ padding: "60px" }}>
        <Stroy />
      </div>
    ),
  ],
};
```

### 8.3.2 Provider를 소유한 테커레이터
로그인한 사용자의 정보가 있는 `Provider`를 데커레이터가 소유했다면, `Context`의 `Provider`에 의존하는 UI 컴포넌트의 스토리에서도 로그인한 사용자의 정보를 표시할 수 있다.<br>
애플리케이션에서 필요한 `Provider`라면 실제 구현 코드와 똑같이 사용해도 상관없지만, 이 밖에는 스토리북 전용 `Provider`를 테커레이터로 만드는 것이 좋다.

```tsx
export const LoginUserInfoProviderDecorator = (
  Stroy: PartialStoryFn<ReactFramework, Args>
) => (
  <LoginUserInfoProvider>
    <Story />
  </LoginUserInfoProvider>
);
```

### 8.3.3 데커레이터 고차 함수
**고차 함수**를 작성하면 데커레이터를 쉽게 만들 수 있다.

`<Toast>` 컴포넌트의 스토리 `createDecorator`라는 고차 함수를 사용해 설정을 최소화한다.
```tsx
export const Succeed: Story = {
  decorators: [createDecorator({ message: "성공했습니다", style: "succeed" })],
};

export const Failed: Story = {
  decorators: [createDecorator({ message: "실패했습니다", style: "failed" })],
};

export const Busy: Story = {
  decorators: [createDecorator({ message: "통신 중입니다", style: "busy" })],
};

function createDecorator(defaultState?: Partial<ToastState>) {
  return function Decorator() {
    return (
      <ToastProvider defaultState={{ ...defaultState, isShown: true }}>
        {null}
      </ToastProvider>
    );
  };
}
```


## 8.4 웹 API에 의존하는 스토리 등록
스토리에도 웹 API가 필요하며, 이와 같이 UI 컴포넌트는 MSW를 사용해야 한다.

### 8.4.1 애드온 설정
스토리북에서 MSW를 사용하려면 `msw`와 `msw-storybook-addon`을 설치해야 한다.
```bash
$ npm install msw msw-storybook-addon --save-dev
```

다음으로 `.storybook/preview.js`에서 `initialize` 함수를 실행해 MSW를 활성화 한다.
```tsx
import { initialize, mswDecorator } from "msw-storybook-addon";
export const decorators = [mswDecorator];
initialize();
```

프로젝트에 처음 MSW를 설치하면 pubilc 디렉터리의 경로를 변경해 줘야 한다.
```bash
$ npm msw init <PUBLIC_DIR>
```

스토리북에서도 public 디렉터리의 경로를 명시한다.
`.storybook/main.js`
```tsx
module.exports = {
  staticDirs: ["../public"],
}
```

### 8.4.2 요청 핸들러 변경
다른 `parameters`와 동일하게 'Global', 'Component', 'Story' 단계별 설정이 가능하다.

- Global 단계: 모든 스토리 적용할 설정(`.storybook/preview.js`)
- Component 단계: 스토리 파일에 적용할 설정(`export default`)
- Story 단계: 개별 스토리에 적용할 설정(`export const`)

모든 스토리에 로그인한 사용자 정보가 필요하다면 `.storybook/preview.js`에 사용자 정보를 반환하는 `MSW` 핸들러를 Global 단계에 설정하는 것이 좋다
```tsx
export const NotLoggedIn: Story = {
  parameters: {
    msw: { 
      handlers: [
        rest.get("/api/my/profile", async (_, res, ctx) => {
          return res(ctx.status(200));
          ... 로그인 정보
        }),
      ], 
    },
  },
};
```

스토리에 적용되는 우선순위 Story > Component > Global 이다. Story 설정으로 미로그인 상태를 반환하도록 덮어쓸 수 있다.
```tsx
export const NotLoggedIn: Story = {
  parameters: {
    msw: { 
      handlers: [
        rest.get("/api/my/profile", async (_, res, ctx) => {
          return res(ctx.status(401));
        }),
      ], 
    },
  },
};
```

### 8.4.3 고차 함수로 요청 핸들러 리팩터링하기
로그인 정보를 응답하는 URL이 변경되면 Global, Story 설정 모두 수정이 필요하다 `handleGetMyProfile` 고차 함수를 사용하여 리팩터링을 해보자
```tsx
msw: { handlers: [handleGetMyProfile({ status: 401 })] ,
//msw:{
//  handlers: [
//    rest.get("/api/my/profile", async (_, res, ctx) => {
//      return res(ctx.status(401));
//    })
//  ]
//}
```


## 8.5 Next.js Router에 의존하는 스토리 등록
UI 컴포넌트에는 특정 URL에서만 사용할 수 있는 컴포넌트가 있다.<br>
`storybook-addon-next-router` 애드온을 추가하면 `Router` 상태를 스토리마다 설정할 수 있다.

### 8.5.1 애드온 설정
애드온을 설치하고 `.storybook/main.js`, `.storybook/preview.js`에 설정을 추가한다.
```bash
$ npm install storybook-addon-next-router --save-dev
```

`.storybook/main.js`
```tsx
module.exports = {
  stories: ["../src/**/*.stories.@(js|jsx|ts|tsx)"],
  addons: ["storybook-addon-next-router"]
};
```

`.storybook/preview.js`
```tsx
import { RouterContext } from "next/dist/shared/lib/router-context";
export const parameters = {
  nextRouter: {
    Provider: RouterContext.Provider,
  },
};  
```

### 8.5.2 Router에 의존하는 스토리 등록 예시
브라우저 URL에 따라 현재 화면에 주황색 선이 그려진다.
```tsx
export const RouteMyPosts: Story = {
  parameters: {
    nextRouter: { pathname: "/my/posts" },
  },
};

export const RouteMyPostsCreate: Story = {
  parameters: {
    nextRouter: { pathname: "/my/posts/create" },
  },
};
```
![image](https://github.com/user-attachments/assets/0c3c6b99-d027-4f04-a33f-8925e721f96f)

![image](https://github.com/user-attachments/assets/44ea63ed-2c2f-4cf2-910e-de22efe782d1)


## 8.6 Play function을 활용한 인터랙션 테스트
인터랙션을 할당하는 방법으로도 재현할 수 있는 상황도 있다. '문자 입력', 'focusout 이벤트', '전송 버튼 클릭' 같은 테스트다.


### 8.6.1 애드온 설정
애드온을 설치하고 `.storybook/main.js`에 설정을 추가한다.
```bash
$ npm install @storybook/testing-library @storybook/jest @storybook/addon-interactions --save-dev
```

`.storybook/main.js`
```tsx
module.exports = {
  stories: ["../src/**/*.stories.@(js|jsx|ts|tsx)"],
  addons: ["@storybook/addon-interactions"],
  features: {
    interactionsDebugger: true,
  },
};
```

### 8.6.2 인터랙션 할당
스토리에 `play` 함수를 설정한다. `jsdom` 때와 동일하게 `userEvent`를 사용하여 할당한다.<br>
테스팅에서 사용하는 `getBy`나 `userEvent`와 거의 동일한 API이므로 자동으로 문자가 입력된 것을 확인할 수 있다.
```tsx
export const SucceedSaveAsDraft: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    await user.type(
      canvas.getByRole("textbox", { name: "제목" }),
      "나의 기사"
    );
  },
};
```
![image](https://github.com/user-attachments/assets/28e85e08-e531-4500-929e-ac0495b5cf75)


### 8.6.3 단언문 작성
`@storybook/jest`의 `expect` 함수를 사용하면 UI 컴포넌트에 인터랙션을 할당한 상태에서 단언문을 작성할 수 있다.<br>
공개 여부 토글 스위치를 클릭하면 버튼의 문자가 '비공개 상태로 저장'에서 '공개하기'로 변경된다.
```tsx
export const SavePublish: Story = {
  play: async ({ canvasElement }) => {
    await user.click(canvas.getByRole("switch", { name: "공개 여부" }));
    await expect(
      canvas.getByRole("button", { name: "공개하기" })
    ).toBeInTheDocument();
  },
};
```
![image](https://github.com/user-attachments/assets/ae121c68-e763-44fa-9f28-77b0fd976c11)
![image](https://github.com/user-attachments/assets/c4fac4e1-8031-43c8-9d73-d13ea9220b3f)

아무것도 입력하지 않고 `비공개 상태로 저장`을 시도하면 유효성 검사가 실패해 오류가 표시된다.
```tsx
export const FailedSaveAsDraft: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    await user.click(canvas.getByRole("button", { name: "비공개 상태로 저장" }));
    const textbox = canvas.getByRole("textbox", { name: "제목" });
    await waitFor(() =>
      expect(textbox).toHaveErrorMessage("한 글자 이상의 문자를 입력해주세요")
    );
  },
};
```

이처럼 Play function으로 스토리북에서 인터랙션 테스트를 작성할 수 있다.


## 8.7 addon-a11y를 활용한 접근성 테스트
스토리북은 컴포넌트 단위로 접근성을 검증하는 용도로도 활용된다.

### 8.7.1 애드온 설정
`@storybook/addon-a11y` 애드온을 추가하면 스토리북 탐색기에서 접근성 관련 우려 사항을 알려준다.<br>
애드온을 설치하고 `.storybook/main.js`에 설정을 추가한다.
```bash
$ npm install @storybook/addon-a11y --save-dev
```

`.storybook/main.js`
```tsx
module.exports = {
  stories: ["../src/**/*.stories.@(js|jsx|ts|tsx)"],
  addons: ["@storybook/addon-a11y"],
};
```

다른 `paraameters`와 동일하게 단계별 설정을 적용할 수 있다. 단계 설명 생략..


### 8.7.2 접근성과 관련한 주의 사항 점검하기

### 8.7.3 일부 규칙 위반을 무효화하기

### 8.7.4 접근성 검증 생략하기


## 8.8 스토리북 테스트 러너

### 8.8.1 테스트 러너를 활용한 일반적인 테스트 자동화

### 8.8.2 테스트 러너를 활용한 Play function 테스트 자동화

### 8.8.3 테스트 러너를 활용한 접근성 테스트 자동화


## 8.9 스토리를 통합 테스트에 재사용하기

### 8.9.1 스토리 재사용

### 8.9.2 스토리를 import하여 테스트 대상으로 만들기

### 8.9.3 @storybook/test-runner와의 차이점

