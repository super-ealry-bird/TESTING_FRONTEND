# Chapter 7. 웹 애플리케이션 통합 테스트
## 7.1 Next.js 애플리케이션 개발과 통합 테스트
> 7장부터는 아래 저장소에 있는 Next.js 애플리케이션을 예제로 사용한다.
> <br/> https://github.com/frontend-testing-book-kr/nextjs

### 7.1.1 애플리케이션 개요

* 기술 관련 기사를 작성하고 공유하는 애플리케이션

### 7.1.2 단위 테스트 및 통합 테스트 실행하기

위의 저장소를 클론하고 단위 테스트와 통합 테스트 실행하기

```shell
$ npm i
$ npm test
$ open __reports__/jest.html
```
📝 테스트 실행결과

![img_1.png](images/img_1.png)

📊 리포트
![img.png](images/img.png)

<br/>

## 7.2 React Context와 통합 테스트

### 7.2.1 테스트할 UI 컴포넌트

* `<Toast />` 컴포넌트
  * 애플리케이션의 응답 결과를 통지하는 컴포넌트
  * 모든 화면에서 호출할 수 있는 전역 UI

Toast 컴포넌트와 같은 전역 UI를 다룰 때 사용하는 기술 **Context API**


> 💡 Context API란?
> 
> Props로 값을 전달할 필요 없이 하위 컴포넌트에서 최상위 컴포넌트가 소유한 값과 갱신 함수에 접근 가능하게 하는 리액트 공식 API


**[ Context API 사용법 ]**

1. `<Toast />` 컴포넌트의 렌더링을 결정하는 상태의 초깃값 세팅
```ts
export const initialState: ToastState = {
  isShown: false,
  message: "",
  style: "succeed",
};
```

2. createContext API 를 사용해 `Context` 생성
```ts
export const ToastStateContext = createContext(initialState);
export const ToastActionContext = createContext(initialAction);
```
* ToastStateContext : 상태를 소유할 Context
* ToastActionContext : 상태 갱신 함수를 소유할 Context

3. 최상위 컴포넌트 `ToastProvider` 렌더링

```ts
export const ToastProvider = ({
  children,
  defaultState,
}: {
  children: ReactNode;
  defaultState?: Partial<ToastState>;
}) => {
  const { isShown, message, style, showToast, hideToast } =
    useToastProvider(defaultState);
  return (
    {/* 하위 컴포넌트에서 isShown, message, style을 참조할 수 있다 */}
    <ToastStateContext.Provider value={{ isShown, message, style }}>
      {/* 하위 컴포넌트에서 showToast, hideToast를 참조할 수 있다 */}
      <ToastActionContext.Provider value={{ showToast, hideToast }}>
        {children}
        {/* isShown이 true가 되면 표시된다 */}
        {isShown && <Toast message={message} style={style} />}
      </ToastActionContext.Provider>
    </ToastStateContext.Provider>
  );
};
```
* 2에서 생성한 `Context` 객체가 소유한 `Provide` 컴포넌트를 렌더링
* ToastProvider로 감싸면 하위 컴포넌트 `children`에서 상태와 상태 갱신 함수에 접근 가능
 
4. 하위 컴포넌트에서 사용하기
```ts
import { useContext } from "react";
import { ToastActionContext } from "./ToastContext";

export function useToastAction() {
  return useContext(ToastActionContext);
}
```
```ts
const { showToast } = useToastAction();
const onSubmit = handleSubmit(async (input) => {
  try {
    // ... 웹 API에 값을 전송한다.
    showToast({ message: "저장됐습니다.", style: "succeed" });
  } catch (err) {
    showToast({ message: "저장에 실패했습니다.", style: "failed" });
  }
});
```
* 하위 컴포넌트에서는 `useContext`를 사용해 접근
* 예제에서는 custom hooks로 만들어서 중복된 코드 사용 ⬇️

Toast 컴포넌트와 같은 전역 UI를 대상으로 실시하는 테스트는 다음과 같은 사항을 중점으로 둔다.

>- `Provider`의 상태에 따라 렌더링 여부가 변경된다.
>- `Provider`의 갱신 함수로 상태를 갱신할 수 있다.


<br />

### 7.2.2 방법① 테스트용 컴포넌트를 만들어 인터랙션 실행하기

전역 UI를 대상으로 Context를 테스트하는 첫 번째 방법 : **테스트용 컴포넌트 만들기**

* 테스트 컴포넌트
```ts
const TestComponent = ({ message }: { message: string }) => {
  const { showToast } = useToastAction(); // <Toast>를 표시하기 위한 훅
  return <button onClick={() => showToast({ message })}>show</button>;
};
```

* 테스트 코드
```ts
test("showToast를 호출하면 Toast컴포넌트가 표시된다", async () => {
  const message = "test";
  // 1. Provider와 테스트 컴포넌트 렌더링
  render(
    <ToastProvider>
      <TestComponent message={message} />
    </ToastProvider>
  );
  // 2. 처음에는 렌더링되지 않음을 테스트
  expect(screen.queryByRole("alert")).not.toBeInTheDocument();
  // 3. 클릭 이벤트 발생
  await user.click(screen.getByRole("button"));
  // 4. 렌더링됐는지 테스트
  expect(screen.getByRole("alert")).toHaveTextContent(message);
});
```

<br/>

### 7.2.3 방법② 초깃값을 주입해서 렌더링된 내용 확인하기

전역 UI를 대상으로 Context를 테스트하는 두 번째 방법 : **초깃값 주입** \
단순히 렌더링 여부를 확인하고 싶을 때 사용 (초깃값을 설정할 수 있도록 구현 필요)

* 테스트 코드
```ts
test("Succeed", () => {
  const state: ToastState = {
    isShown: true,
    message: "성공했습니다",
    style: "succeed",
  };
  render(<ToastProvider defaultState={state}>{null}</ToastProvider>);
  expect(screen.getByRole("alert")).toHaveTextContent(state.message);
});

test("Failed", () => {
  const state: ToastState = {
    isShown: true,
    message: "실패했습니다",
    style: "failed",
  };
  render(<ToastProvider defaultState={state}>{null}</ToastProvider>);
  expect(screen.getByRole("alert")).toHaveTextContent(state.message);
});
```

> 💡 초깃값을 주입하는 두 번째 방법보다는 Toast 컴포넌트를 렌더링하고 조작하는 데 필요한 아래 네 가지 모듈을 모두 테스트할 수 있는 첫 번째 방법이 더 넓은 범위의 통합 테스트이다.
> * `Toast` : view 제공 및 테스트할 컴포넌트
> * `ToastProvider` : 렌더링 여부를 결정할 상태를 소유
> * `useToastProvider` : 렌더링 관련 로직을 관리 
> * `useToastAction, useToastState` : 하위 컴포넌트에서 호출하는 hooks

<br/>

## 7.3 Next.js 라우터와 렌더링 통합 테스트

### 7.3.1 테스트할 UI 컴포넌트

* `<Nav />` 컴포넌트
  * 헤더 내비게이셔을 담당하는 UI 컴포넌트
  * URL에 따라 내비게이션 메뉴에 현재 위치를 나타냄

<br />

### 7.3.2 UI 컴포넌트 구현

Nav 컴포넌트는 a태그에 `aria-current` 라는 속성을 사용해서 스타일을 적용하고 있다.
```html
<a aria-current="page">Create Post</a>
```

```css
.list a[aria-current="page"] {
  border-color: var(--orange);
}
```
`aria-current` 속성을 가지는 마크업을 출력하기 위해 사용하는 isCurrent 함수

```ts
function isCurrent(flag: boolean): AnchorHTMLAttributes<HTMLAnchorElement> {
  if (!flag) return {};
  return { "aria-current": "page" };
}
```

```ts
<a {...isCurrent(pathname === "/my/posts/create")}>Create Post</a>
```
현재 URL 정보인 pathname을 가져오기 위해서 Next.js의 useRouter 훅을 사용
```ts
const { pathname } = useRouter();
```
***위와 같이 Next.js의 라우터와 관련된 컴포넌트를 테스트하려면 목 객체가 필요!***

<br />

### 7.3.3 next-router-mock 설치

> 💡 next-router-mock 이란?
>
> 제스트에서 Next.js의 라우터를 테스트할 수 있도록 목 객체를 제공하는 라이브러리

```shell
$ npm install --save-dev next-router-mock
```

### 7.3.4 라우터와 UI 컴포넌트 통합 테스트
`next-router-mock`을 사용해 테스트 코드를 작성
* 테스트 코드
```ts
test("현재 위치는 'My Posts'이다", () => {
  // 1. setCurrentUrl를 사용해 테스트 환경의 URL 설정
  mockRouter.setCurrentUrl("/my/posts");
  // 2. 테스트 대상인 Nav 컴포넌트 렌더링
  render(<Nav onCloseMenu={() => {}} />);
  // 3. aria-current 속성을 검증해 테스트
  const link = screen.getByRole("link", { name: "My Posts" });
  expect(link).toHaveAttribute("aria-current", "page");
});
```

### 7.3.5 test.each 활용

* 동일한 테스트를 매개변수만 변경해 반복하고 싶은 경우 -> `test.each` 활용

```ts
test.each([
  { url: "/my/posts", name: "My Posts" },
  { url: "/my/posts/123", name: "My Posts" },
  { url: "/my/posts/create", name: "Create Post" },
])("$url의 현재 위치는 $name이다", ({ url, name }) => {
  mockRouter.setCurrentUrl(url);
  render(<Nav onCloseMenu={() => {}} />);
  const link = screen.getByRole("link", { name });
  expect(link).toHaveAttribute("aria-current", "page");
});
```

> 💡Next.js 13버전에는 라우터 구조가 크게 변경된 app directory가 탑재되었다. 예제는 Next.js 12의 pages directory를 기반으로 작성되어 있다.

<br />

## 7.4 Next.js 라우터와 입력 통합 테스트

### 7.4.1 테스트할 UI 컴포넌트

* `<Header />` 컴포넌트
  * 기사 목록의 헤더 컴포넌트
  * select 버튼으로 라우터를 조작해 URL 매개변수를 변경

<br />

### 7.4.2 초기 화면 테스트

UI 컴포넌트의 통합 테스트에 앞서 아래와 같은 설정 함수를 사용하면 모든 테스트에서 필요한 설정을 한 곳에서 간편하게 처리할 수 있다.
* 설정 함수
  * 테스트 컴포넌트 렌더링
  * 요소 취득 및 반환
  * URL 설정 등..
```ts
function setup(url = "/my/posts?page=1") {
  mockRouter.setCurrentUrl(url);
  render(<Header />);
  const combobox = screen.getByRole("combobox", { name: "공개 여부" });
  return { combobox };
}
```

* 설정 함수를 활용해서 작성한 테스트 코드
```ts
test("기본값으로 '모두'가 선택되어 있다", async () => {
  const { combobox } = setup();
  expect(combobox).toHaveDisplayValue("모두");
});

test("status?=public으로 접속하면 '공개'가 선택되어 있다", async () => {
  const { combobox } = setup("/my/posts?status=public");
  expect(combobox).toHaveDisplayValue("공개");
});

test("staus?=private으로 접속하면 '비공개'가 선택되어 있다", async () => {
  const { combobox } = setup("/my/posts?status=private");
  expect(combobox).toHaveDisplayValue("비공개");
});
```

<br />

### 7.4.3 인터랙션 테스트
인터랙션 테스트를 위해 설정 함수에 userEvent를 활용한 인터랙션 함수 추가
* 설정 함수
```ts
const user = userEvent.setup();

function setup(url = "/my/posts?page=1") {
  mockRouter.setCurrentUrl(url);
  render(<Header />);
  const combobox = screen.getByRole("combobox", { name: "공개 여부" });
  async function selectOption(label: string) {
    await user.selectOptions(combobox, label);
  }
  return { combobox, selectOption };
}
```
* 테스트 코드
```ts
test("공개 여부를 변경하면 status가 변한다", async () => {
  const { selectOption } = setup();
  expect(mockRouter).toMatchObject({ query: { page: "1" } });
  
  // 1. '공개'를 선택
  await selectOption("공개");
  // 2. 기존의 page=1이 그대로 있는지,status가 public인지 함께 검증
  expect(mockRouter).toMatchObject({
    query: { page: "1", status: "public" },
  });
  
  // 3. '비공개'를 선택
  await selectOption("비공개");
  // 4. 기존의 page=1이 그대로 있는지,status가 private인지 함께 검증
  expect(mockRouter).toMatchObject({
    query: { page: "1", status: "private" },
  });
});
```

<br />

## 7.5 React Hook Form으로 폼 쉽게 다루기
### 7.5.1 제어 컴포넌트
### 7.5.2 비제어 컴포넌트
### 7.5.3 React Hook Form과 비제어 컴포넌트

<br />

## 7.6 폼 유효성 검사 테스트
### 7.6.1 테스트할 UI 컴포넌트
### 7.6.2 설계 포인트
### 7.6.3 인터랙션 테스트 설정
### 7.6.4 onInvalid가 실행되는 테스트
### 7.6.5 onValid가 실행되는 테스트
### 7.6.6 TIP: 접근성 관련 매치

<br />

## 7.7 웹 API 응답을 목 객체화하는 MSW
### 7.7.1 네트워크 계층의 목 객체를 만드는 MSW
### 7.7.2 제스트에서 사용하기
### 7.7.3 Fetch API의 폴리필

<br />

## 7.8 웹 API 통합 테스트
### 7.8.1 테스트할 UI 컴포넌트
### 7.8.2 인터랙션 테스트 설정
### 7.8.3 AlertDialog 렌더링 테스트
### 7.8.4 Toast 렌더링 테스트
### 7.8.5 화면 이동 테스트

<br />

## 7.9 이미지 업로드 통합 테스트
### 7.9.1 테스트할 UI 컴포넌트
### 7.9.2 이미지 업로드 처리 흐름
### 7.9.3 통합 테스트용 목 객체 만들기
### 7.9.4 업로드 성공 테스트
### 7.9.5 업로드 실패 테스트


