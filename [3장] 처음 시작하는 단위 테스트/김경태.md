# [3장] 처음 시작하는 단위 테스트 😀⚔️👾


## 3.1 환경설정
이 책에선 테스트 코드를 작성할 때 제스트를 사용한다.
- js,타입스크립트에서 가장 인기 많은 테스트 코드

### 3.1.1 개발 환경설정
1. node.js LTS 최신 버전 설치
2. https://github.com/frontend-testing-book-kr/unittest.git url 저장소에 클론
3. 커맨드로 모듈 설치 - npm i

## 3.2 테스트 구성 요소
이 책의 코드 경로는 아래와 같은 규칙을 사용
- 예제 코드: src/03/02

### 3.2.1 가장 단순한 테스트
```typescript
    export function add(a: number, b: number) {
      return a + b;
    }
    
    export function sub(a: number, b: number) {
      return a - b;
    }
```
index.ts(구현 파일)

```typescript
    import { add } from "./";
    test("add: 1 + 1은 2", () => {
      expect(add(1, 1)).toBe(2);
    });
```
index.test.ts(테스트 파일)

테스트는 구현 파일에 작성하지 않고 별도의 파일을 만들어 테스트 대상(여기선 add 함수)을 import로 불러와 테스트 한다.

- 테스트 파일을 반드시 구현 파일과 같은 디렉토리에 둘 필요는 없다.
- 저장소 최상위에 __test__라는 디렉토리를 만들고 이 디렉토리 안에 있는 테스트 파일들을 테스트하는 방식도 많이 사용됨
-> 결국은 마음대로 해도 됨

### 3.2.2 테스트 구성 요소
테스트는 제스트가 제공하는 API인 test 함수로 정의

test 함수는 2개의 매개변수를 받는다

- test(테스트명, 테스트 함수);
  + 첫 번째 인수인 테스트명은 테스트 내용을 잘 알 수 있는 제목을 할당한다.
    * test(" 1 + 2는 3");
  + 두 번째 인수인 테스트 함수ㅔ는 단언문을 작성. 단언문은 검증값이 기댓값과 일치하는지 검증하는 문 이다.
    * test(" 1 + 2는 3", () => {
      expect(검증값).toBe(기댓값);
      });
   
  + 이 때 단언문은 expect 함수와 이에 덧붙이는 매처로 구성되어 있다.
    * 매처: toBe(기댓값)
   
### 3.2.3 테스트 그룹 작성
연관성 있는 테스트를 그룹화하고 싶을 땐? => describe함수를 사용

- describe 함수는 test와 유사하게 **describe(그룹명, 그룹 함수)** 2개의 매개변수로 구성된다.

ex) 테스트 그룹의 예시
```typescript
describe("사칙연산", () => {
  describe("add", () => {
    test("1 + 1은 2", () => {
      expect(add(1, 1)).toBe(2);
    });
    test("1 + 2는 3", () => {
      expect(add(1, 2)).toBe(3);
    });
  });
  describe("sub", () => {
    test("1 - 1은 0", () => {
      expect(sub(1, 1)).toBe(0);
    });
    test("2 - 1은 1", () => {
      expect(sub(2, 1)).toBe(1);
    });
  });
});
```

describe 함수는 해당 코드에 볼 수 있듯이 중첩이 가능하다.
사칙연산 그룹 안에 add,sub 그룹이 묶여 있다.

## 3.3 테스트 실행 방법
- 작성한 테스트를 개발 환경에서 실행하는 방법은 크게 두 가지가 있다.

### 3.3.1 명령줄 인터페이스로 실행

1. package.json에 npm script를 추가
    {
      "scripts": {
        "test": "jest"
      }
    }
위의 스크립트 추가 후 아래와 같은 명령어로 실행한다.

- $ npm test
// 모든 테스트 실행
- $npm test 'src/03/02/index.test.ts'
// 해당 파일 하나 테스트 실행

### 3.3.2 제스트 러너로 실행
개별 파일 경로를 터미널에 직접 입력하는 것은 번거롭고 파일명이 틀리기도 쉽다.
따라서 제스트 러너 를 사용하는 방법도 존재한다.

1. 테스트가 성공하였을 때
<img width="259" alt="image" src="https://github.com/user-attachments/assets/72cae373-3eb2-48ea-a540-0487584e518e">
<img width="714" alt="image" src="https://github.com/user-attachments/assets/e56cc5c9-ff6d-41c2-8585-4afa3d5b219d">

이런식으로 확인 가능하다.

2. 실패한 테스트가 있는 경우
<img width="492" alt="image" src="https://github.com/user-attachments/assets/617210d1-67ed-4b80-a080-94f127533c1e">
<img width="697" alt="image" src="https://github.com/user-attachments/assets/0cdb6209-69e6-4a36-be27-788f0ce189a7">
</br>
기댓값은 3이지만 실제 결과는 2라는 의미
- 이 경우 문제가 있는 것이 명확하기 때문에 테스트 코드를 수정해야 한다.
만약 테스트 코드,대상에도 문제 없이 실패한다면 버그가 있다는 의미이다.

## 3.4 조건 분기
테스트는 모듈이 의도 대로 구현되었는지 검증할 때 도움이 된다.
당연히 사양이 복잡할 수록 조건 분기에서 버그가 많이 생긴다. **즉 조건분기가 있는 부분은 특별히 주의하여** 테스트를 해야 한다.

### 상한이 있는 덧셈 함수 테스트
- p36.조건을 사용해 상한 설정이 가능하다.
- 단) test함수를 사용할 때는 어떤 의도로 작성됐는지, 어떤 작업이 포함됐는지 테스트명으로 정확히 표현해야 한다.(이건 모든 test에 적용되는 내용이다.)
- 70+80=100 true면 이상하기 때문 - 반환값의 상한은 '100'이다 이런식으로 표시  

### 하한이 있는 뺄셈 함수 테스트
- p37. 상한과 마찬가지로 뺄셈에서 하한 설정이 가능하다. 

## 3.5 에지 케이스와 예외 처리
- 실수 등의 이유로 예상하지 못한 입력값을 보낼 때가 있다.
- 이 때 해당 모듈에 예외 처리를 했다면 예상하지 못한 입력값을 받았을 때 실행 중인 디버거로 문제를 빨리 발견 가능


### 3.5.1 타입스크립트로 입력값 제약 설정
- 타입스크립트를 사용하는 프로젝트는 함수의 매개변수에 타입 애너테이션을 붙일 수 있다.
- 타입 애너테이션을 실행하면 다른 타입의 값이 할당되면 실행하기 전에 오류가 발생함
- 타입 애너테이션 예시 : function add(x: number, y: number): number 

### 3.5.2 예외 발생시키기

```typescript
export function add(a: number, b: number) {
  if (a < 0 || a > 100) {
    throw new Error("0〜100 사이의 값을 입력해주세요"); 
  }
  if (b < 0 || b > 100) {
    throw new Error("0〜100 사이의 값을 입력해주세요");
  }
  const sum = a + b;
  if (sum > 100) {
    return 100; 
  }
  return sum; 
}
```
a와 b의 값이 0~100 사이의 number가 아닌 경우 예외를 발생시킨다.

### 3.5.3 예외 발생 검증 테스트
- 먼저 expect 인수로 값이 아닌 예외가 발생하는 함수를 할당하고, 매처로 toThrow를 사용
```typescript
test("올바른 단언문 작성법", () => {
  // 잘못된 작성법
  expect(add(-10, 110)).toThrow();
  // 올바른 작성법
  expect(() => add(-10, 110)).toThrow();
});
```
- 이런식으로 사용된다.

### 3.5.4 오류 메시지를 활용한 세부 사항 검증
```typescript
test("인수가 '0~100'의 범위밖이면 예외가 발생한다", () => {
  expect(() => add(110, -10)).toThrow("0〜1000 사이의 값을 입력해주세요");
});
```
- toThrow에 인수를 할당하여 더 상세한 내용 검증이 가능하다.
  
### 3.5.5 instanceof 연산자를 활용한 세부 사항 검증
- Error 클래스를 더욱 구체적인 상황에 맞춰 작성 가능하다.
```typescript
/* 코드 3-20
if (err instanceof HttpError) {
  // 발생한 에러가 HttpError인 경우
}
if (err instanceof RangeError) {
  // 발생한 에러가 RangeError인 경우
}
```
그 외에 RangeError 인스턴스는 p.41부터 확인이 가능하다.


## 3.6 용도별 매처
테스트 검증에 사용하는 다양한 매처를 살펴본다.

### 3.6.1 진릿 값 검증

### 3.6.2 수치 검증

### 3.6.3 문자열 검증

### 3.6.4 배열 검증

### 3.6.5 객체 검증

## 3.7 비동기 처리 테스트

### 3.7.1 테스트할 함수

### 3.7.2 promise를 반환하는 작성법

### 3.7.2 async/await를 활용하는 작성법

### 3.7.3 테스트 결과가 기댓값과 일치하는지 확인하기
