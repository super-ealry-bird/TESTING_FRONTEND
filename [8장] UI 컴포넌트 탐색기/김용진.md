# [8장] UI 컴포넌트 탐색기

---

## 8.1 스토리북 기초
UI 컴포넌트 탐색기는 구현된 UI 컴포넌트를 쉽게 공유할 수 있도록 도와주는 협업 도구다.
최근에는 UI 컴포넌트 탐색기를 협업 도구가 아닌 테스트에 활용하는 사례가 많아졌다.

기존의 프런트엔드 테스트는 다음의 두 가지 테스트를 의미했다.

- `jsdom`을 사용한 단위 테스트 및 통합테스트
- 브라우저를 사용한 E2E 테스트

스토리북의 UI컴포넌트 테스트는 이 두 가지 테스트의 중간에 위치한 테스트다.
![image](https://github.com/user-attachments/assets/e99d101e-ac17-4b37-85c7-16d917615d49)

### 8.1.1 스토리북 설치
스토리북 설치
```bash
$ npx storybook init
```

```bash
  storybook@8.2.9
Ok to proceed? (y)
```

스토리북 실행 http://localhost:6006/ 에 실행된다.
```bash
$ npm run storybook
```

### 8.1.2 스토리 등록
스토리를 등록하려면 프로젝트에 스토리 파일을 추가해야 한다.<br>
예제 코드 `Button.jsx`라는 UI 컴포넌트를 스토리 등록을 위해 필요한 스토리 파일 Button.stories.jsx 다.
```tsx
import { Button } from "./Button";

export default {
  title: "Example/Button",
  component: Button,
};
```

UI 컴포넌트 Props의 조합으로 다른 스타일과 작동을 제공할 수 있다.
Button 문자열을 표시할 때는 label 이라는 Props를 지정한다. ( 스토리북에서는 Props에 해당하는 변수명이 args 이다.)
```tsx
export const Default = {
  args: {
    label: "Button"
  }
};
```

size가 다른 `export` 객체 이름으로 개별 스토리 등록 
```tsx
export const Large = {
  args: {
    size: "large"
    label: "Button"
  }
};

export const Small = {
  args: {
    size: "small"
    label: "Button"
  }
};
```

### 8.1.3 3단계 깊은 병합
모든 스토리에는 'Global', Component', 'Story' 세 단계의 설정이 깊은 병합 방식으로 적용된다.

- Global 단계: 모든 스토리에 적용할 설정 (.storybook/preview.js)
- Component 단계: 스토리 파일에 적용할 설정 (export default)
- Story 단계: 개별 스토리에 적용할 설정 (export const)


## 8.2 스토리북 필수 애드온
스토리북은 애드온으로 필요한 기능을 추가할 수 있다. 설치시 기본적으로 추가되는 `@storybook/addon-essentials`은 필수 애드온 이다.

### 8.2.1 Controls를 활용한 디버깅
UI 컴포넌트는 Props에 전달된 값에 따라 다른 스타일과 기능을 제공한다. 스토리북 탐색기에서는 `Props`를 변경해 컴포넌트가 어떻게 표시되는지 실시간으로 디버깅할 수 있다. 이를 **Controls**라고 한다.

`Props`(`children`, `theme`, `variant`, `disabled`)를 변경하면 UI 컴포넌트가 어떻게 변화하는지 바로 확인할 수 있다.
![image](https://github.com/user-attachments/assets/548ffa1d-2b82-49e4-ab98-ebb491fcb9e5)

`@stroybook/addon-controls`라는 애드온이 제공하는 기능이며, 스도리북을 설치할 때 적용되는 `@storybook/addon-essentials`에 포함되어 있다.

### 8.2.2 Actions를 활용한 이벤트 핸들러 검증
UI 컴포넌트는 내부 로직을 처리할 때 `Props`로 전달받은 이벤트 핸들러를 호출하기도 한다. 이벤트 핸들러가 어떻게 호출됐는지 로그를 출력하는 기능이 **Actions**이며, `@stroybook/addon-actions`패키지에서 제공한다. `@storybook/addon-essentials`에 포함되어 있다.

title를 입력하지 않고, 저장하려고 하면 `onInvalid` 호출됐고 로그를 확인할 수 있다.
![image](https://github.com/user-attachments/assets/c24a1c83-3582-4768-969d-a9f22ceb7de6)


Global 단계 설정으로 `on`으로 시작하는 모든 이벤트 핸들러는 자동적으로 Actions 패널에 로그를 출력하게 된다.
핸들러 이름이 다른 경우 정규표현식을 수정해야 한다.
```tsx
export const parameters = {
  actions: { argTypesRegex: "^on[A-Z].*" },
};
```

### 8.2.3 반응형 대응을 위한 뷰포트 설정
반응형으로 구현한 UI 컴포넌트는 화면 크기별로 스토리를 등록할 수 있다. `@stroybook/addon-viewport`패키지에서 지원한다.

![image](https://github.com/user-attachments/assets/5cdd27d2-222f-4051-b93e-a7f0d34199d1)

레이아웃으로 스토리를 등록하려면 `parameters.viewport`를 설정해야한다. SP(스마트폰) `SPStroy`라는 공통된 설정을 만들었다.
```tsx
export const SPStory = {
  parameters: {
    viewport: {
      viewports: INITIAL_VIEWPORTS,
      defaultViewport: "iphone6",
    },
    screenshot: {  // 시각적 회기 테스트를 위한 설정
      viewport: {
        width: 375,
        height: 667,
        deviceScaleFactor: 1,
      },
      fullPage: false,
    },
  },
};

// 스마트폰 로그인 화면 
export const SPLoggedIn: Story = {
  parameters: {
    ...SPStory.parameters,
  },
}

// PC 로그인 화면 
export const PCLoggedIn: Story = {
  parameters: {
    ...PCStory.parameters,
  },
}
```

## 8.3 Context API에 의존하는 스토리 등록
Context API에 의존하는 스토리에는 **데커레이터**를 활용하는 것이 편리하다. 초깃값을 주입할 수 있도록 Provider를 만들면 Context의 상태에 의존하는 UI를 간단하게 재현할 수 있다.

### 8.3.1 스토리북의 데커레이터
데커레이터는 각 스토리의 렌더링 함수에 적용할 **래퍼**다. UI 컴포넌트 바깥쪽에 여백을 만들고 싶다면 데커레이터를 `decorators` 배열에 추가한다.
```tsx
import { ChildComponent } from "./";

export default {
  title: "ChildComponent",
  component: ChildComponent,
  decorators: [
    (Story) => (
      <div style={{ padding: "60px" }}>
        <Stroy />
      </div>
    ),
  ],
};
```

### 8.3.2 Provider를 소유한 테커레이터
로그인한 사용자의 정보가 있는 `Provider`를 데커레이터가 소유했다면, `Context`의 `Provider`에 의존하는 UI 컴포넌트의 스토리에서도 로그인한 사용자의 정보를 표시할 수 있다.<br>
애플리케이션에서 필요한 `Provider`라면 실제 구현 코드와 똑같이 사용해도 상관없지만, 이 밖에는 스토리북 전용 `Provider`를 테커레이터로 만드는 것이 좋다.

```tsx
export const LoginUserInfoProviderDecorator = (
  Stroy: PartialStoryFn<ReactFramework, Args>
) => (
  <LoginUserInfoProvider>
    <Story />
  </LoginUserInfoProvider>
);
```

### 8.3.3 데커레이터 고차 함수
**고차 함수**를 작성하면 데커레이터를 쉽게 만들 수 있다.

`<Toast>` 컴포넌트의 스토리 `createDecorator`라는 고차 함수를 사용해 설정을 최소화한다.
```tsx
export const Succeed: Story = {
  decorators: [createDecorator({ message: "성공했습니다", style: "succeed" })],
};

export const Failed: Story = {
  decorators: [createDecorator({ message: "실패했습니다", style: "failed" })],
};

export const Busy: Story = {
  decorators: [createDecorator({ message: "통신 중입니다", style: "busy" })],
};

function createDecorator(defaultState?: Partial<ToastState>) {
  return function Decorator() {
    return (
      <ToastProvider defaultState={{ ...defaultState, isShown: true }}>
        {null}
      </ToastProvider>
    );
  };
}
```


## 8.4 웹 API에 의존하는 스토리 등록


### 8.4.1 애드온 설정

### 8.4.2 요청 핸들러 변경

### 8.4.3 고차 함수로 요청 핸들러 리팩터링하기


## 8.5 Next.js Router에 의존하는 스토리 등록

### 8.5.1 애드온 설정

### 8.5.2 Router에 의존하는 스토리 등록 예시



## 8.6 Play function을 활용한 인터랙션 테스트

### 8.6.1 애드온 설정

### 8.6.2 인터랙션 할당

### 8.6.3 단언문 작성


## 8.7 addon-a11y를 활용한 접근성 테스트

### 8.7.1 애드온 설정

### 8.7.2 접근성과 관련한 주의 사항 점검하기

### 8.7.3 일부 규칙 위반을 무효화하기

### 8.7.4 접근성 검증 생략하기


## 8.8 스토리북 테스트 러너

### 8.8.1 테스트 러너를 활용한 일반적인 테스트 자동화

### 8.8.2 테스트 러너를 활용한 Play function 테스트 자동화

### 8.8.3 테스트 러너를 활용한 접근성 테스트 자동화


## 8.9 스토리를 통합 테스트에 재사용하기

### 8.9.1 스토리 재사용

### 8.9.2 스토리를 import하여 테스트 대상으로 만들기

### 8.9.3 @storybook/test-runner와의 차이점

